,title,description,templateCode,answer01_code,answer01_hint,answer01_desc,answer02_code,answer02_hint,answer02_desc,answer03_code,answer03_hint,answer03_desc
,Q1. 文字列を逆にせよ,与えられた文字列を逆順にして返す関数 `reverseString` を作成してください。,function reverseString(str) {\n  // ここに書くコードを考えてください\n},let result = '';\nfor (let i = str.length - 1; i >= 0; i--) {\n  result += str[i];\n}\nreturn result;,末尾から1文字ずつ結合,文字列の最後の文字から順番に、新しい文字列に1文字ずつ追加していく方法です。例えば「こんにちは」という文字列なら、「は」「ち」「に」「ん」「こ」の順に結合していきます。,return str.split('').reverse().join('');,配列操作で一括変換,split()メソッドで文字列を1文字ずつに分けて配列にし、reverse()メソッドで配列を逆順にして、join()メソッドでまた1つの文字列に戻す方法です。短いコードで書けますが、文字列を何度も変換する必要があります。,return Array.from(str).reverse().join('');,Array.fromで文字列変換,Array.from()メソッドで文字列を配列に変換し、reverse()メソッドで逆順にして、join()メソッドで文字列に戻す方法です。split()の代わりにArray.from()を使うことで、より安全に文字列を配列に変換できます。
,Q2. 配列の合計を求めよ,整数の配列を受け取り、その合計を返す関数 `sumArray` を作成してください。,function sumArray(arr) {\n  // ここに書くコードを考えてください\n},let total = 0;\nfor (let i = 0; i < arr.length; i++) {\n  total += arr[i];\n}\nreturn total;,for文で順次加算,"配列の数字を1つずつ順番に足し合わせていく方法です。例えば[1, 2, 3]という配列なら、0から始めて1を足し、2を足し、3を足して、最終的に6になります。","return arr.reduce((sum, n) => sum + n, 0);",reduceで集計,reduce()メソッドを使って配列の数字をまとめて足し合わせる方法です。最初に0を設定し、そこに配列の数字を1つずつ足していきます。短いコードで書けますが、少し理解しにくいかもしれません。,,,
,Q3. 偶数のみ抽出,整数配列から偶数だけを抽出して返す関数 `filterEven` を作成してください。,function filterEven(arr) {\n  // ここに書くコードを考えてください\n},const result = [];\nfor (let i = 0; i < arr.length; i++) {\n  if (arr[i] % 2 === 0) {\n    result.push(arr[i]);\n  }\n}\nreturn result;,for文で条件分岐,"配列の数字を1つずつ確認し、2で割り切れる数（偶数）だけを新しい配列に追加していく方法です。例えば[1, 2, 3, 4]という配列なら、[2, 4]という配列ができます。",return arr.filter(n => n % 2 === 0);,filterで条件抽出,filter()メソッドを使って配列から条件に合う数字だけを選び出す方法です。2で割り切れる数だけを選び出して新しい配列を作ります。短いコードで書けますが、少し理解しにくいかもしれません。,,,
,Q4. 文字数をカウントせよ,与えられた文字列の長さを返す関数 `getLength` を作成してください。,function getLength(str) {\n  // ここに書くコードを考えてください\n},let count = 0;\nfor (let i = 0; i < str.length; i++) {\n  count++;\n}\nreturn count;,for文で1文字ずつカウント,文字列の文字を1つずつ数えていく方法です。例えば「こんにちは」という文字列なら、1文字目、2文字目...と数えていき、最終的に5という数字が得られます。,return str.length;,lengthプロパティ使用,文字列の長さを直接取得する方法です。lengthプロパティを使うことで、文字列の長さを簡単に取得できます。最も簡単で効率的な方法です。,,,
,Q5. 最大値を見つけよ,整数の配列から最大値を返す関数 `getMax` を作成してください。,function getMax(arr) {\n  // ここに書くコードを考えてください\n},let max = arr[0];\nfor (let i = 1; i < arr.length; i++) {\n  if (arr[i] > max) {\n    max = arr[i];\n  }\n}\nreturn max;,for文で最大値更新,配列の最初の数字を最大値として覚えておき、それ以降の数字と1つずつ比較していく方法です。より大きい数字が見つかったら、それを新しい最大値として覚えます。,return Math.max(...arr);,Math.maxで一括取得,Math.max()メソッドを使って配列の中から一番大きい数字を直接見つける方法です。短いコードで書けますが、配列が大きい場合は少し時間がかかるかもしれません。,,,
,Q6. 配列をソートせよ,整数配列を小さい順に並び替える関数 `sortArray` を作成してください。隣り合う2つの数を比較して、大きい方を右に移動させる方法を使ってください。,function sortArray(arr) {\n  // ここに書くコードを考えてください\n},const result = [...arr];\nfor (let i = 0; i < result.length - 1; i++) {\n  for (let j = 0; j < result.length - i - 1; j++) {\n    if (result[j] > result[j + 1]) {\n      const temp = result[j];\n      result[j] = result[j + 1];\n      result[j + 1] = temp;\n    }\n  }\n}\nreturn result;,隣り合う数を比較して交換,"隣り合う2つの数字を比較して、左の数字が右の数字より大きい場合は入れ替える方法です。これを繰り返すことで、最終的に小さい順に並びます。例えば[3, 1, 4, 2]という配列なら、[1, 2, 3, 4]になります。","return arr.sort((a, b) => a - b);",sortメソッド使用,sort()メソッドを使って配列を並び替える方法です。数字を小さい順に並べるための簡単な方法ですが、配列の中身が変わってしまうことに注意が必要です。,,,
,Q7. 本棚から本を探す,本棚に本が背表紙の高さ順に並んでいます。特定の高さの本を探す関数 `findBook` を作成してください。,"function findBook(books, targetHeight) {\n  // ここに書くコードを考えてください\n}",let left = 0;\nlet right = books.length - 1;\nwhile (left <= right) {\n  const mid = Math.floor((left + right) / 2);\n  if (books[mid] === targetHeight) return mid;\n  if (books[mid] < targetHeight) left = mid + 1;\n  else right = mid - 1;\n}\nreturn -1;,本棚を半分ずつ探す,本棚を半分に分けて探していく方法です。例えば10冊の本がある場合、まず5冊目の本を確認し、探している本より背表紙が低ければ後半を、高ければ前半を探します。これを繰り返して目的の本を見つけます。,return books.indexOf(targetHeight);,順番に探す,indexOf()メソッドを使って本棚の本を1冊ずつ順番に確認していく方法です。探している本の高さと一致する本を見つけたら、その位置を返します。見つからない場合は-1を返します。,,,
,Q8. 階段の上り方,n段の階段があります。1段ずつ、または2段ずつ上ることができます。n段目までの上り方の総数を求める関数 `countWays` を作成してください。,function countWays(n) {\n  // ここに書くコードを考えてください\n},"if (n <= 1) return 1;\nlet a = 1, b = 1;\nfor (let i = 2; i <= n; i++) {\n  [a, b] = [b, a + b];\n}\nreturn b;",順番に計算,1段目と2段目の上り方の数を覚えておき、それ以降は前の2つの数を足し合わせていく方法です。例えば3段目なら、1段目と2段目の上り方の数を足した数になります。,if (n <= 1) return 1;\nreturn countWays(n - 1) + countWays(n - 2);,再帰で計算,階段の上り方を、1段前と2段前の上り方の数の合計として計算する方法です。シンプルですが、同じ計算を何度も繰り返すため、段数が多くなると時間がかかります。,const memo = {};\nfunction ways(n) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return 1;\n  memo[n] = ways(n - 1) + ways(n - 2);\n  return memo[n];\n}\nreturn ways(n);,計算結果を覚えておく,一度計算した結果を覚えておき、同じ計算を繰り返さないようにする方法です。例えば3段目の上り方を計算したら、その結果を覚えておき、後で同じ計算が必要になったときに再利用します。
,Q9. 文字列の前後一致判定,与えられた文字列が前から読んでも後ろから読んでも同じになるかどうかを判定する関数 `isPalindrome` を作成してください。,function isPalindrome(str) {\n  // ここに書くコードを考えてください\n},let left = 0;\nlet right = str.length - 1;\nwhile (left < right) {\n  if (str[left] !== str[right]) return false;\n  left++;\n  right--;\n}\nreturn true;,両端から1文字ずつ比較,文字列の最初と最後の文字から順番に比較していく方法です。例えば「しんぶんし」という文字列なら、「し」と「し」、「ん」と「ん」、「ぶ」と「ぶ」を比較します。,return str === str.split('').reverse().join('');,文字列を反転して比較,split()メソッドで文字列を1文字ずつに分け、reverse()メソッドで配列を逆順にして、join()メソッドで文字列に戻してから比較する方法です。例えば「しんぶんし」という文字列なら、逆順にしても「しんぶんし」になるので、回文だと分かります。,"const cleanStr = str.toLowerCase().replace(/[^a-z0-9]/g, '');\nreturn cleanStr === cleanStr.split('').reverse().join('');",記号を除いて比較,"toLowerCase()メソッドで文字列を小文字に変換し、replace()メソッドで記号を除いてから回文かどうかを判定する方法です。例えば「A man, a plan, a canal: Panama」という文字列なら、記号を除いて「amanaplanacanalpanama」となり、回文だと分かります。"
,Q10. 配列の重複を削除,配列から重複する要素を削除する関数 `removeDuplicates` を作成してください。,function removeDuplicates(arr) {\n  // ここに書くコードを考えてください\n},const result = [];\nfor (const item of arr) {\n  if (!result.includes(item)) {\n    result.push(item);\n  }\n}\nreturn result;,for文で重複チェック,"配列の要素を1つずつ確認し、新しい配列にまだ入っていない要素だけを追加していく方法です。例えば[1, 2, 2, 3, 3, 3]という配列なら、[1, 2, 3]という配列ができます。",return [...new Set(arr)];,Setで一括削除,Setオブジェクトを使って重複する要素を自動的に取り除く方法です。短いコードで書けますが、配列の要素がどのように処理されるかを理解する必要があります。,"return arr.filter((item, index) => arr.indexOf(item) === index);",filterで重複除去,filter()メソッドとindexOf()メソッドを組み合わせて重複を除去する方法です。配列の要素を順番に確認し、その要素が最初に現れる位置と現在の位置が同じ場合だけを残します。重複する要素は、最初に現れる位置以外では除外されます。
,Q11. 宝探し,n個の部屋が一列に並んでいます。各部屋には宝の有無が記録されています。宝が隠されている部屋を全て見つける関数 `findTreasures` を作成してください。,function findTreasures(rooms) {\n  // ここに書くコードを考えてください\n},const result = [];\nfor (let i = 0; i < rooms.length; i++) {\n  if (rooms[i]) {\n    result.push(i);\n  }\n}\nreturn result;,順番に確認,"部屋を1つずつ順番に確認し、宝がある部屋（trueの値）の番号を新しい配列に追加していく方法です。例えば[false, true, false, true]という配列なら、[1, 3]という配列ができます。","return rooms.map((hasTreasure, index) => hasTreasure ? index : -1).filter(index => index !== -1);",配列操作で一括処理,map()メソッドとfilter()メソッドを組み合わせて部屋の情報を一度に処理する方法です。宝がある部屋の番号を残し、宝がない部屋は-1に変換してから、-1以外の番号だけを残します。,,,
