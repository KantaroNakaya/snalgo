[
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "カウンターコンポーネント",
        "description": "ボタンをクリックすると数値が増減するカウンターコンポーネント `Counter` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction Counter() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [count, setCount] = useState(0);\n\nreturn (\n  <div>\n    <h2>カウンター: {count}</h2>\n    <button onClick={() => setCount(count + 1)}>+1</button>\n    <button onClick={() => setCount(count - 1)}>-1</button>\n  </div>\n);",
        "answer01_hint": "useStateで状態管理",
        "answer01_desc": "useStateフックを使ってカウントの状態を管理し、ボタンクリック時にsetCount関数で状態を更新する方法です。最も基本的なReactの状態管理の例です。",
        "answer02_code": "const [count, setCount] = useState(0);\n\nconst increment = () => setCount(prev => prev + 1);\nconst decrement = () => setCount(prev => prev - 1);\n\nreturn (\n  <div>\n    <h2>カウンター: {count}</h2>\n    <button onClick={increment}>+1</button>\n    <button onClick={decrement}>-1</button>\n  </div>\n);",
        "answer02_hint": "関数を分離して整理",
        "answer02_desc": "インクリメントとデクリメントの処理を別々の関数に分離して、コードを整理する方法です。関数型更新（prev => prev + 1）を使うことで、より安全に状態を更新できます。",
        "answer03_code": "const [count, setCount] = useState(0);\n\nconst handleClick = (increment) => {\n  setCount(prev => prev + increment);\n};\n\nreturn (\n  <div>\n    <h2>カウンター: {count}</h2>\n    <button onClick={() => handleClick(1)}>+1</button>\n    <button onClick={() => handleClick(-1)}>-1</button>\n  </div>\n);",
        "answer03_hint": "汎用的な関数で処理",
        "answer03_desc": "1つの関数で増減両方の処理を行う汎用的な方法です。引数で増減の値を指定することで、コードの重複を減らすことができます。"
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "Todoリスト",
        "description": "新しいタスクを追加・削除できるTodoリストコンポーネント `TodoList` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [todos, setTodos] = useState([]);\nconst [input, setInput] = useState('');\n\nconst addTodo = () => {\n  if (input.trim()) {\n    setTodos([...todos, input]);\n    setInput('');\n  }\n};\n\nconst removeTodo = (index) => {\n  setTodos(todos.filter((_, i) => i !== index));\n};\n\nreturn (\n  <div>\n    <input value={input} onChange={(e) => setInput(e.target.value)} />\n    <button onClick={addTodo}>追加</button>\n    <ul>\n      {todos.map((todo, index) => (\n        <li key={index}>\n          {todo}\n          <button onClick={() => removeTodo(index)}>削除</button>\n        </li>\n      ))}\n    </ul>\n  </div>\n);",
        "answer01_hint": "配列でタスク管理",
        "answer01_desc": "todos配列でタスクを管理し、新しいタスクは配列の末尾に追加、削除はfilter関数で該当するインデックスのタスクを除外する方法です。基本的な配列操作を使った実装です。",
        "answer02_code": "const [todos, setTodos] = useState([]);\nconst [input, setInput] = useState('');\n\nconst addTodo = () => {\n  if (input.trim()) {\n    const newTodo = { id: Date.now(), text: input, completed: false };\n    setTodos([...todos, newTodo]);\n    setInput('');\n  }\n};\n\nconst toggleTodo = (id) => {\n  setTodos(todos.map(todo => \n    todo.id === id ? { ...todo, completed: !todo.completed } : todo\n  ));\n};\n\nconst removeTodo = (id) => {\n  setTodos(todos.filter(todo => todo.id !== id));\n};\n\nreturn (\n  <div>\n    <input value={input} onChange={(e) => setInput(e.target.value)} />\n    <button onClick={addTodo}>追加</button>\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <input type=\"checkbox\" checked={todo.completed} onChange={() => toggleTodo(todo.id)} />\n          <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            {todo.text}\n          </span>\n          <button onClick={() => removeTodo(todo.id)}>削除</button>\n        </li>\n      ))}\n    </ul>\n  </div>\n);",
        "answer02_hint": "オブジェクトで詳細管理",
        "answer02_desc": "タスクをオブジェクトとして管理し、完了状態も含める方法です。IDを使ってタスクを識別し、完了状態の切り替えも可能になります。より実用的なTodoリストの実装です。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "フォーム入力",
        "description": "名前、メール、メッセージを入力できるフォームコンポーネント `ContactForm` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction ContactForm() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [formData, setFormData] = useState({\n  name: '',\n  email: '',\n  message: ''\n});\n\nconst handleChange = (e) => {\n  setFormData({\n    ...formData,\n    [e.target.name]: e.target.value\n  });\n};\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n  console.log('送信データ:', formData);\n};\n\nreturn (\n  <form onSubmit={handleSubmit}>\n    <div>\n      <label>名前:</label>\n      <input\n        type=\"text\"\n        name=\"name\"\n        value={formData.name}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>メール:</label>\n      <input\n        type=\"email\"\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>メッセージ:</label>\n      <textarea\n        name=\"message\"\n        value={formData.message}\n        onChange={handleChange}\n      />\n    </div>\n    <button type=\"submit\">送信</button>\n  </form>\n);",
        "answer01_hint": "オブジェクトで状態管理",
        "answer01_desc": "フォームの各フィールドを1つのオブジェクトで管理し、handleChange関数で動的に状態を更新する方法です。スプレッド演算子を使って既存の状態を保持しながら特定のフィールドのみを更新します。",
        "answer02_code": "const [name, setName] = useState('');\nconst [email, setEmail] = useState('');\nconst [message, setMessage] = useState('');\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n  console.log('送信データ:', { name, email, message });\n};\n\nreturn (\n  <form onSubmit={handleSubmit}>\n    <div>\n      <label>名前:</label>\n      <input\n        type=\"text\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n    </div>\n    <div>\n      <label>メール:</label>\n      <input\n        type=\"email\"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n      />\n    </div>\n    <div>\n      <label>メッセージ:</label>\n      <textarea\n        value={message}\n        onChange={(e) => setMessage(e.target.value)}\n      />\n    </div>\n    <button type=\"submit\">送信</button>\n  </form>\n);",
        "answer02_hint": "個別の状態管理",
        "answer02_desc": "各フィールドを個別のuseStateで管理する方法です。シンプルで理解しやすいですが、フィールドが多くなるとコードが冗長になります。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "条件付きレンダリング",
        "description": "ログイン状態に応じて異なるコンテンツを表示するコンポーネント `UserProfile` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction UserProfile() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [isLoggedIn, setIsLoggedIn] = useState(false);\nconst [username, setUsername] = useState('');\n\nconst handleLogin = () => {\n  if (username.trim()) {\n    setIsLoggedIn(true);\n  }\n};\n\nconst handleLogout = () => {\n  setIsLoggedIn(false);\n  setUsername('');\n};\n\nreturn (\n  <div>\n    {isLoggedIn ? (\n      <div>\n        <h2>ようこそ、{username}さん！</h2>\n        <p>プロフィール情報がここに表示されます。</p>\n        <button onClick={handleLogout}>ログアウト</button>\n      </div>\n    ) : (\n      <div>\n        <h2>ログインしてください</h2>\n        <input\n          type=\"text\"\n          placeholder=\"ユーザー名\"\n          value={username}\n          onChange={(e) => setUsername(e.target.value)}\n        />\n        <button onClick={handleLogin}>ログイン</button>\n      </div>\n    )}\n  </div>\n);",
        "answer01_hint": "三項演算子で条件分岐",
        "answer01_desc": "三項演算子（? :）を使ってログイン状態に応じて異なるJSXを表示する方法です。最も一般的な条件付きレンダリングのパターンです。",
        "answer02_code": "const [isLoggedIn, setIsLoggedIn] = useState(false);\nconst [username, setUsername] = useState('');\n\nconst handleLogin = () => {\n  if (username.trim()) {\n    setIsLoggedIn(true);\n  }\n};\n\nconst handleLogout = () => {\n  setIsLoggedIn(false);\n  setUsername('');\n};\n\nconst renderLoginForm = () => (\n  <div>\n    <h2>ログインしてください</h2>\n    <input\n      type=\"text\"\n      placeholder=\"ユーザー名\"\n      value={username}\n      onChange={(e) => setUsername(e.target.value)}\n    />\n    <button onClick={handleLogin}>ログイン</button>\n  </div>\n);\n\nconst renderProfile = () => (\n  <div>\n    <h2>ようこそ、{username}さん！</h2>\n    <p>プロフィール情報がここに表示されます。</p>\n    <button onClick={handleLogout}>ログアウト</button>\n  </div>\n);\n\nreturn (\n  <div>\n    {isLoggedIn ? renderProfile() : renderLoginForm()}\n  </div>\n);",
        "answer02_hint": "関数でJSXを分離",
        "answer02_desc": "条件に応じて表示するJSXを別々の関数に分離して、コードを整理する方法です。複雑な条件付きレンダリングでは可読性が向上します。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "リスト表示",
        "description": "配列のデータをリストとして表示するコンポーネント `ProductList` を作成してください。",
        "templateCode": "import React from 'react';\n\nfunction ProductList() {\n  const products = [\n    { id: 1, name: '商品A', price: 1000 },\n    { id: 2, name: '商品B', price: 2000 },\n    { id: 3, name: '商品C', price: 1500 }\n  ];\n\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "return (\n  <div>\n    <h2>商品一覧</h2>\n    <ul>\n      {products.map(product => (\n        <li key={product.id}>\n          <h3>{product.name}</h3>\n          <p>価格: ¥{product.price}</p>\n        </li>\n      ))}\n    </ul>\n  </div>\n);",
        "answer01_hint": "mapで配列を変換",
        "answer01_desc": "map()メソッドを使って配列の各要素をJSXに変換する方法です。keyプロパティでReactに各要素を識別させることが重要です。最も基本的なリスト表示のパターンです。",
        "answer02_code": "const renderProduct = (product) => (\n  <li key={product.id}>\n    <h3>{product.name}</h3>\n    <p>価格: ¥{product.price}</p>\n  </li>\n);\n\nreturn (\n  <div>\n    <h2>商品一覧</h2>\n    <ul>\n      {products.map(renderProduct)}\n    </ul>\n  </div>\n);",
        "answer02_hint": "関数でJSXを分離",
        "answer02_desc": "各商品のJSXを別々の関数に分離して、コードを整理する方法です。複雑なリスト項目では可読性が向上し、再利用も容易になります。",
        "answer03_code": "return (\n  <div>\n    <h2>商品一覧</h2>\n    <div className=\"product-grid\">\n      {products.map(product => (\n        <div key={product.id} className=\"product-card\">\n          <h3>{product.name}</h3>\n          <p>価格: ¥{product.price.toLocaleString()}</p>\n          <button>カートに追加</button>\n        </div>\n      ))}\n    </div>\n  </div>\n);",
        "answer03_hint": "グリッドレイアウトで表示",
        "answer03_desc": "ul/liの代わりにdivを使ってグリッドレイアウトで商品を表示する方法です。toLocaleString()で価格をフォーマットし、より実用的な商品リストの実装です。"
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "useEffectの使用",
        "description": "コンポーネントがマウントされた時にAPIからデータを取得するコンポーネント `DataFetcher` を作成してください。",
        "templateCode": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\n  const fetchData = async () => {\n    try {\n      setLoading(true);\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n      const jsonData = await response.json();\n      setData(jsonData);\n    } catch (err) {\n      setError(err.message);\n    }\n    finally {\n      setLoading(false);\n    }\n  };\n\n  fetchData();\n}, []);\n\nif (loading) return <div>読み込み中...</div>;\nif (error) return <div>エラー: {error}</div>;\nif (!data) return <div>データがありません</div>;\n\nreturn (\n  <div>\n    <h2>{data.title}</h2>\n    <p>{data.body}</p>\n  </div>\n);",
        "answer01_hint": "async/awaitでデータ取得",
        "answer01_desc": "useEffectフックを使ってコンポーネントマウント時にデータを取得し、loading、error、dataの状態を管理する方法です。最も一般的なデータ取得のパターンです。",
        "answer02_code": "const [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\n\nuseEffect(() => {\n  fetch('https://jsonplaceholder.typicode.com/posts/1')\n    .then(response => response.json())\n    .then(jsonData => {\n      setData(jsonData);\n      setLoading(false);\n    })\n    .catch(error => {\n      console.error('データ取得エラー:', error);\n      setLoading(false);\n    });\n}, []);\n\nif (loading) return <div>読み込み中...</div>;\nif (!data) return <div>データがありません</div>;\n\nreturn (\n  <div>\n    <h2>{data.title}</h2>\n    <p>{data.body}</p>\n  </div>\n);",
        "answer02_hint": "Promiseチェーンでデータ取得",
        "answer02_desc": "Promiseチェーン（.then/.catch）を使ってデータを取得する方法です。async/awaitよりも古い書き方ですが、理解しやすい場合があります。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "カスタムフック",
        "description": "カウンターの機能をカスタムフックとして実装し、それを使用するコンポーネント `CustomCounter` を作成してください。",
        "templateCode": "import React from 'react';\n\n// カスタムフックを作成\nfunction useCounter(initialValue = 0) {\n  // ここに書くコードを考えてください\n}\n\nfunction CustomCounter() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "function useCounter(initialValue = 0) {\n  const [count, setCount] = React.useState(initialValue);\n\n  const increment = () => setCount(prev => prev + 1);\n  const decrement = () => setCount(prev => prev - 1);\n  const reset = () => setCount(initialValue);\n\n  return { count, increment, decrement, reset };\n}\n\nfunction CustomCounter() {\n  const { count, increment, decrement, reset } = useCounter(0);\n\n  return (\n    <div>\n      <h2>カウンター: {count}</h2>\n      <button onClick={increment}>+1</button>\n      <button onClick={decrement}>-1</button>\n      <button onClick={reset}>リセット</button>\n    </div>\n  );\n}",
        "answer01_hint": "ロジックを分離",
        "answer01_desc": "カウンターのロジックをカスタムフックとして分離し、コンポーネントで再利用可能にする方法です。ロジックとUIを分離することで、コードの再利用性と保守性が向上します。",
        "answer02_code": "function useCounter(initialValue = 0, step = 1) {\n  const [count, setCount] = React.useState(initialValue);\n\n  const increment = () => setCount(prev => prev + step);\n  const decrement = () => setCount(prev => prev - step);\n  const reset = () => setCount(initialValue);\n  const setValue = (value) => setCount(value);\n\n  return { count, increment, decrement, reset, setValue };\n}\n\nfunction CustomCounter() {\n  const { count, increment, decrement, reset } = useCounter(0, 5);\n\n  return (\n    <div>\n      <h2>カウンター: {count}</h2>\n      <button onClick={increment}>+5</button>\n      <button onClick={decrement}>-5</button>\n      <button onClick={reset}>リセット</button>\n    </div>\n  );\n}",
        "answer02_hint": "パラメータ付きカスタムフック",
        "answer02_desc": "カスタムフックにパラメータを追加して、より柔軟に使用できるようにする方法です。初期値とステップ値を設定できるため、様々な用途に応用できます。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "コンポーネント間通信",
        "description": "親コンポーネントから子コンポーネントにデータを渡し、子コンポーネントから親コンポーネントにイベントを送る実装を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction ParentComponent() {\n  // ここに書くコードを考えてください\n}\n\nfunction ChildComponent({ data, onUpdate }) {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "function ParentComponent() {\n  const [parentData, setParentData] = useState('親のデータ');\n\n  const handleChildUpdate = (newData) => {\n    setParentData(newData);\n  };\n\n  return (\n    <div>\n      <h2>親コンポーネント</h2>\n      <p>データ: {parentData}</p>\n      <ChildComponent \n        data={parentData} \n        onUpdate={handleChildUpdate} \n      />\n    </div>\n  );\n}\n\nfunction ChildComponent({ data, onUpdate }) {\n  const [childInput, setChildInput] = useState('');\n\n  const handleSubmit = () => {\n    onUpdate(childInput);\n    setChildInput('');\n  };\n\n  return (\n    <div>\n      <h3>子コンポーネント</h3>\n      <p>親から受け取ったデータ: {data}</p>\n      <input\n        value={childInput}\n        onChange={(e) => setChildInput(e.target.value)}\n        placeholder=\"新しいデータを入力\"\n      />\n      <button onClick={handleSubmit}>親に送信</button>\n    </div>\n  );\n}",
        "answer01_hint": "propsでデータとコールバックを渡す",
        "answer01_desc": "親コンポーネントから子コンポーネントにデータとコールバック関数をpropsで渡し、子コンポーネントから親コンポーネントにイベントを送る基本的なパターンです。Reactの最も重要な概念の一つです。",
        "answer02_code": "function ParentComponent() {\n  const [parentData, setParentData] = useState('親のデータ');\n  const [childMessages, setChildMessages] = useState([]);\n\n  const handleChildUpdate = (newData) => {\n    setParentData(newData);\n  };\n\n  const handleChildMessage = (message) => {\n    setChildMessages(prev => [...prev, message]);\n  };\n\n  return (\n    <div>\n      <h2>親コンポーネント</h2>\n      <p>データ: {parentData}</p>\n      <ul>\n        {childMessages.map((msg, index) => (\n          <li key={index}>{msg}</li>\n        ))}\n      </ul>\n      <ChildComponent \n        data={parentData} \n        onUpdate={handleChildUpdate}\n        onMessage={handleChildMessage}\n      />\n    </div>\n  );\n}\n\nfunction ChildComponent({ data, onUpdate, onMessage }) {\n  const [childInput, setChildInput] = useState('');\n\n  const handleSubmit = () => {\n    onUpdate(childInput);\n    onMessage(`子から送信: ${childInput}`);\n    setChildInput('');\n  };\n\n  return (\n    <div>\n      <h3>子コンポーネント</h3>\n      <p>親から受け取ったデータ: {data}</p>\n      <input\n        value={childInput}\n        onChange={(e) => setChildInput(e.target.value)}\n        placeholder=\"新しいデータを入力\"\n      />\n      <button onClick={handleSubmit}>親に送信</button>\n    </div>\n  );\n}",
        "answer02_hint": "複数のコールバックで通信",
        "answer02_desc": "複数のコールバック関数を使って、より複雑な親子間通信を実装する方法です。データの更新とメッセージの送信を分離することで、より柔軟な通信が可能になります。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "フォームバリデーション",
        "description": "入力値の検証機能付きフォームコンポーネント `ValidatedForm` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction ValidatedForm() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [formData, setFormData] = useState({\n  email: '',\n  password: '',\n  confirmPassword: ''\n});\n\nconst handleChange = (e) => {\n  setFormData({\n    ...formData,\n    [e.target.name]: e.target.value\n  });\n};\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n  console.log('送信データ:', formData);\n};\n\nreturn (\n  <form onSubmit={handleSubmit}>\n    <div>\n      <label>メールアドレス:</label>\n      <input\n        type=\"email\"\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>パスワード:</label>\n      <input\n        type=\"password\"\n        name=\"password\"\n        value={formData.password}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>パスワード確認:</label>\n      <input\n        type=\"password\"\n        name=\"confirmPassword\"\n        value={formData.confirmPassword}\n        onChange={handleChange}\n      />\n    </div>\n    <button type=\"submit\">送信</button>\n  </form>\n);",
        "answer01_hint": "エラー状態を管理",
        "answer01_desc": "フォームデータとエラーメッセージを別々の状態で管理し、送信時にバリデーションを実行する方法です。各フィールドの下にエラーメッセージを表示し、ユーザーに分かりやすくフィードバックを提供します。",
        "answer02_code": "const [formData, setFormData] = useState({\n  email: '',\n  password: '',\n  confirmPassword: ''\n});\nconst [errors, setErrors] = useState({});\n\nconst validateForm = () => {\n  const newErrors = {};\n\n  if (!formData.email) {\n    newErrors.email = 'メールアドレスは必須です';\n  } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(formData.email)) {\n    newErrors.email = '有効なメールアドレスを入力してください';\n  }\n\n  if (!formData.password) {\n    newErrors.password = 'パスワードは必須です';\n  } else if (formData.password.length < 6) {\n    newErrors.password = 'パスワードは6文字以上で入力してください';\n  }\n\n  if (formData.password !== formData.confirmPassword) {\n    newErrors.confirmPassword = 'パスワードが一致しません';\n  }\n\n  setErrors(newErrors);\n  return Object.keys(newErrors).length === 0;\n};\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n  if (validateForm()) {\n    console.log('フォーム送信:', formData);\n  }\n};\n\nconst handleChange = (e) => {\n  setFormData({\n    ...formData,\n    [e.target.name]: e.target.value\n  });\n};\n\nreturn (\n  <form onSubmit={handleSubmit}>\n    <div>\n      <label>メールアドレス:</label>\n      <input\n        type=\"email\"\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>パスワード:</label>\n      <input\n        type=\"password\"\n        name=\"password\"\n        value={formData.password}\n        onChange={handleChange}\n      />\n    </div>\n    <div>\n      <label>パスワード確認:</label>\n      <input\n        type=\"password\"\n        name=\"confirmPassword\"\n        value={formData.confirmPassword}\n        onChange={handleChange}\n      />\n    </div>\n    <button type=\"submit\">送信</button>\n  </form>\n);",
        "answer02_hint": "リアルタイムバリデーション",
        "answer02_desc": "フィールドがフォーカスを失った時（onBlur）にバリデーションを実行し、リアルタイムでエラーを表示する方法です。touched状態でフィールドが操作されたかどうかを追跡し、より良いユーザー体験を提供します。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    },
    {
        "contentId": "",
        "language": "JavaScript",
        "framework": "React",
        "title": "モーダルダイアログ",
        "description": "ボタンをクリックすると開閉するモーダルダイアログコンポーネント `Modal` を作成してください。",
        "templateCode": "import React, { useState } from 'react';\n\nfunction Modal() {\n  // ここに書くコードを考えてください\n}",
        "answer01_code": "const [isOpen, setIsOpen] = useState(false);\n\nconst openModal = () => setIsOpen(true);\nconst closeModal = () => setIsOpen(false);\n\nreturn (\n  <div>\n    <button onClick={openModal}>モーダルを開く</button>\n    \n    {isOpen && (\n      <div style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        backgroundColor: 'rgba(0, 0, 0, 0.5)',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        zIndex: 1000\n      }}>\n        <div style={{\n          backgroundColor: 'white',\n          padding: '20px',\n          borderRadius: '8px',\n          maxWidth: '500px',\n          width: '90%'\n        }}>\n          <h2>モーダルタイトル</h2>\n          <p>これはモーダルダイアログの内容です。</p>\n          <button onClick={closeModal}>閉じる</button>\n        </div>\n      </div>\n    )}\n  </div>\n);",
        "answer01_hint": "条件付きレンダリングで表示制御",
        "answer01_desc": "isOpen状態でモーダルの表示/非表示を制御し、条件付きレンダリングでモーダルを表示する方法です。固定位置とオーバーレイを使ってモーダルらしい見た目を実現します。",
        "answer02_code": "const [isOpen, setIsOpen] = useState(false);\n\nconst openModal = () => setIsOpen(true);\nconst closeModal = () => setIsOpen(false);\n\nconst handleBackdropClick = (e) => {\n  if (e.target === e.currentTarget) {\n    closeModal();\n  }\n};\n\nreturn (\n  <div>\n    <button onClick={openModal}>モーダルを開く</button>\n    \n    {isOpen && (\n      <div \n        style={{\n          position: 'fixed',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          zIndex: 1000\n        }}\n        onClick={handleBackdropClick}\n      >\n        <div style={{\n          backgroundColor: 'white',\n          padding: '20px',\n          borderRadius: '8px',\n          maxWidth: '500px',\n          width: '90%'\n        }}>\n          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n            <h2>モーダルタイトル</h2>\n            <button onClick={closeModal} style={{ border: 'none', background: 'none', fontSize: '20px' }}>\n              ×\n            </button>\n          </div>\n          <p>これはモーダルダイアログの内容です。</p>\n          <div style={{ textAlign: 'right', marginTop: '20px' }}>\n            <button onClick={closeModal}>閉じる</button>\n          </div>\n        </div>\n      </div>\n    )}\n  </div>\n);",
        "answer02_hint": "バックドロップクリックで閉じる",
        "answer02_desc": "モーダルの背景（バックドロップ）をクリックしても閉じることができるようにし、右上に×ボタンを追加する方法です。より直感的なユーザー体験を提供します。",
        "answer03_code": "",
        "answer03_hint": "",
        "answer03_desc": ""
    }
]